package stdops

import (
	"gorgonia.org/gorgonia/ops"
	"gorgonia.org/gorgonia/values"
	"gorgonia.org/tensor/dense"
)

// Code generated by genops, which is a ops generation tool for Gorgonia. DO NOT EDIT.

// Add creates an ops.Op that is correct to the shape of the given operands.
func Add[DT any, T values.Value[DT]](a, b ops.Operand) ops.PreallocOp[DT, T] {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return addVV[DT, T]{}
	case !aScalar && bScalar:
		return addVS[DT, T]{}
	case aScalar && !bScalar:
		return addSV[DT, T]{}
	}
}

// Sub creates an ops.Op that is correct to the shape of the given operands.
func Sub[DT any, T values.Value[DT]](a, b ops.Operand) ops.PreallocOp[DT, T] {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return subVV[DT, T]{}
	case !aScalar && bScalar:
		return subVS[DT, T]{}
	case aScalar && !bScalar:
		return subSV[DT, T]{}
	}
}

// Mul creates an ops.Op that is correct to the shape of the given operands.
func Mul[DT any, T values.Value[DT]](a, b ops.Operand) ops.PreallocOp[DT, T] {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return mulVV[DT, T]{}
	case !aScalar && bScalar:
		return mulVS[DT, T]{}
	case aScalar && !bScalar:
		return mulSV[DT, T]{}
	}
}

// Div creates an ops.Op that is correct to the shape of the given operands.
func Div[DT any, T values.Value[DT]](a, b ops.Operand) ops.PreallocOp[DT, T] {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return divVV[DT, T]{}
	case !aScalar && bScalar:
		return divVS[DT, T]{}
	case aScalar && !bScalar:
		return divSV[DT, T]{}
	}
}

// Pow creates an ops.Op that is correct to the shape of the given operands.
func Pow[DT any, T values.Value[DT]](a, b ops.Operand) ops.PreallocOp[DT, T] {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return powVV[DT, T]{}
	case !aScalar && bScalar:
		return powVS[DT, T]{}
	case aScalar && !bScalar:
		return powSV[DT, T]{}
	}
}

// Mod creates an ops.Op that is correct to the shape of the given operands.
func Mod[DT any, T values.Value[DT]](a, b ops.Operand) ops.PreallocOp[DT, T] {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return modVV[DT, T]{}
	case !aScalar && bScalar:
		return modVS[DT, T]{}
	case aScalar && !bScalar:
		return modSV[DT, T]{}
	}
}

// Lt creates an ops.Op that is correct to the shape of the given operands.
func Lt[DT any, T values.Value[DT], U values.V](a, b ops.Operand) ops.Desc {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	var z1 T
	var z2 U
	retSame := any(z1) == any(z2)
	if retSame {
		switch {
		default:
			fallthrough
		case !aScalar && !bScalar:
			return ltVVRS[DT, T]{}
		case !aScalar && bScalar:
			return ltVSRS[DT, T]{}
		case aScalar && !bScalar:
			return ltSVRS[DT, T]{}
		}
	}

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return ltVV[DT, T, *dense.Dense[bool]]{}
	case !aScalar && bScalar:
		return ltVS[DT, T, *dense.Dense[bool]]{}
	case aScalar && !bScalar:
		return ltSV[DT, T, *dense.Dense[bool]]{}
	}
}

// Lte creates an ops.Op that is correct to the shape of the given operands.
func Lte[DT any, T values.Value[DT], U values.V](a, b ops.Operand) ops.Desc {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	var z1 T
	var z2 U
	retSame := any(z1) == any(z2)
	if retSame {
		switch {
		default:
			fallthrough
		case !aScalar && !bScalar:
			return lteVVRS[DT, T]{}
		case !aScalar && bScalar:
			return lteVSRS[DT, T]{}
		case aScalar && !bScalar:
			return lteSVRS[DT, T]{}
		}
	}

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return lteVV[DT, T, *dense.Dense[bool]]{}
	case !aScalar && bScalar:
		return lteVS[DT, T, *dense.Dense[bool]]{}
	case aScalar && !bScalar:
		return lteSV[DT, T, *dense.Dense[bool]]{}
	}
}

// Gt creates an ops.Op that is correct to the shape of the given operands.
func Gt[DT any, T values.Value[DT], U values.V](a, b ops.Operand) ops.Desc {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	var z1 T
	var z2 U
	retSame := any(z1) == any(z2)
	if retSame {
		switch {
		default:
			fallthrough
		case !aScalar && !bScalar:
			return gtVVRS[DT, T]{}
		case !aScalar && bScalar:
			return gtVSRS[DT, T]{}
		case aScalar && !bScalar:
			return gtSVRS[DT, T]{}
		}
	}

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return gtVV[DT, T, *dense.Dense[bool]]{}
	case !aScalar && bScalar:
		return gtVS[DT, T, *dense.Dense[bool]]{}
	case aScalar && !bScalar:
		return gtSV[DT, T, *dense.Dense[bool]]{}
	}
}

// Gte creates an ops.Op that is correct to the shape of the given operands.
func Gte[DT any, T values.Value[DT], U values.V](a, b ops.Operand) ops.Desc {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	var z1 T
	var z2 U
	retSame := any(z1) == any(z2)
	if retSame {
		switch {
		default:
			fallthrough
		case !aScalar && !bScalar:
			return gteVVRS[DT, T]{}
		case !aScalar && bScalar:
			return gteVSRS[DT, T]{}
		case aScalar && !bScalar:
			return gteSVRS[DT, T]{}
		}
	}

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return gteVV[DT, T, *dense.Dense[bool]]{}
	case !aScalar && bScalar:
		return gteVS[DT, T, *dense.Dense[bool]]{}
	case aScalar && !bScalar:
		return gteSV[DT, T, *dense.Dense[bool]]{}
	}
}

// ElEq creates an ops.Op that is correct to the shape of the given operands.
func ElEq[DT any, T values.Value[DT], U values.V](a, b ops.Operand) ops.Desc {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	var z1 T
	var z2 U
	retSame := any(z1) == any(z2)
	if retSame {
		switch {
		default:
			fallthrough
		case !aScalar && !bScalar:
			return elEqVVRS[DT, T]{}
		case !aScalar && bScalar:
			return elEqVSRS[DT, T]{}
		case aScalar && !bScalar:
			return elEqSVRS[DT, T]{}
		}
	}

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return elEqVV[DT, T, *dense.Dense[bool]]{}
	case !aScalar && bScalar:
		return elEqVS[DT, T, *dense.Dense[bool]]{}
	case aScalar && !bScalar:
		return elEqSV[DT, T, *dense.Dense[bool]]{}
	}
}

// ElNe creates an ops.Op that is correct to the shape of the given operands.
func ElNe[DT any, T values.Value[DT], U values.V](a, b ops.Operand) ops.Desc {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	var z1 T
	var z2 U
	retSame := any(z1) == any(z2)
	if retSame {
		switch {
		default:
			fallthrough
		case !aScalar && !bScalar:
			return elNeVVRS[DT, T]{}
		case !aScalar && bScalar:
			return elNeVSRS[DT, T]{}
		case aScalar && !bScalar:
			return elNeSVRS[DT, T]{}
		}
	}

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return elNeVV[DT, T, *dense.Dense[bool]]{}
	case !aScalar && bScalar:
		return elNeVS[DT, T, *dense.Dense[bool]]{}
	case aScalar && !bScalar:
		return elNeSV[DT, T, *dense.Dense[bool]]{}
	}
}

// Abs creates an ops.Op that performs the named operation.
func Abs[DT any, T values.Value[DT]]() ops.PreallocOp[DT, T] {
	return absOp[DT, T]{}
}

// Sign creates an ops.Op that performs the named operation.
func Sign[DT any, T values.Value[DT]]() ops.PreallocOp[DT, T] {
	return signOp[DT, T]{}
}

// Ceil creates an ops.Op that performs the named operation.
func Ceil[DT any, T values.Value[DT]]() ops.PreallocOp[DT, T] {
	return ceilOp[DT, T]{}
}

// Floor creates an ops.Op that performs the named operation.
func Floor[DT any, T values.Value[DT]]() ops.PreallocOp[DT, T] {
	return floorOp[DT, T]{}
}

// Sin creates an ops.Op that performs the named operation.
func Sin[DT any, T values.Value[DT]]() ops.PreallocOp[DT, T] {
	return sinOp[DT, T]{}
}

// Cos creates an ops.Op that performs the named operation.
func Cos[DT any, T values.Value[DT]]() ops.PreallocOp[DT, T] {
	return cosOp[DT, T]{}
}

// Exp creates an ops.Op that performs the named operation.
func Exp[DT any, T values.Value[DT]]() ops.PreallocOp[DT, T] {
	return expOp[DT, T]{}
}

// Ln creates an ops.Op that performs the named operation.
func Ln[DT any, T values.Value[DT]]() ops.PreallocOp[DT, T] {
	return lnOp[DT, T]{}
}

// Log2 creates an ops.Op that performs the named operation.
func Log2[DT any, T values.Value[DT]]() ops.PreallocOp[DT, T] {
	return log2Op[DT, T]{}
}

// Neg creates an ops.Op that performs the named operation.
func Neg[DT any, T values.Value[DT]]() ops.PreallocOp[DT, T] {
	return negOp[DT, T]{}
}

// Square creates an ops.Op that performs the named operation.
func Square[DT any, T values.Value[DT]]() ops.PreallocOp[DT, T] {
	return squareOp[DT, T]{}
}

// Sqrt creates an ops.Op that performs the named operation.
func Sqrt[DT any, T values.Value[DT]]() ops.PreallocOp[DT, T] {
	return sqrtOp[DT, T]{}
}

// Inv creates an ops.Op that performs the named operation.
func Inv[DT any, T values.Value[DT]]() ops.PreallocOp[DT, T] {
	return invOp[DT, T]{}
}

// InvSqrt creates an ops.Op that performs the named operation.
func InvSqrt[DT any, T values.Value[DT]]() ops.PreallocOp[DT, T] {
	return invSqrtOp[DT, T]{}
}

// Log1p creates an ops.Op that performs the named operation.
func Log1p[DT any, T values.Value[DT]]() ops.PreallocOp[DT, T] {
	return log1pOp[DT, T]{}
}

// Expm1 creates an ops.Op that performs the named operation.
func Expm1[DT any, T values.Value[DT]]() ops.PreallocOp[DT, T] {
	return expm1Op[DT, T]{}
}

// Cube creates an ops.Op that performs the named operation.
func Cube[DT any, T values.Value[DT]]() ops.PreallocOp[DT, T] {
	return cubeOp[DT, T]{}
}

// Tanh creates an ops.Op that performs the named operation.
func Tanh[DT any, T values.Value[DT]]() ops.PreallocOp[DT, T] {
	return tanhOp[DT, T]{}
}
