package stdops

import (
	"gorgonia.org/gorgonia/ops"
	"gorgonia.org/gorgonia/values"
	"gorgonia.org/tensor/dense"
)

// Code generated by genops, which is a ops generation tool for Gorgonia. DO NOT EDIT.

// Add creates an ops.Op that is correct to the shape of the given operands.
func Add[DT any, T values.Value[DT]](a, b ops.Operand) ops.PreallocOp[DT, T] {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return addVV[DT, T]{}
	case !aScalar && bScalar:
		return addVS[DT, T]{}
	case aScalar && !bScalar:
		return addSV[DT, T]{}
	}
}

// Sub creates an ops.Op that is correct to the shape of the given operands.
func Sub[DT any, T values.Value[DT]](a, b ops.Operand) ops.PreallocOp[DT, T] {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return subVV[DT, T]{}
	case !aScalar && bScalar:
		return subVS[DT, T]{}
	case aScalar && !bScalar:
		return subSV[DT, T]{}
	}
}

// Mul creates an ops.Op that is correct to the shape of the given operands.
func Mul[DT any, T values.Value[DT]](a, b ops.Operand) ops.PreallocOp[DT, T] {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return mulVV[DT, T]{}
	case !aScalar && bScalar:
		return mulVS[DT, T]{}
	case aScalar && !bScalar:
		return mulSV[DT, T]{}
	}
}

// Div creates an ops.Op that is correct to the shape of the given operands.
func Div[DT any, T values.Value[DT]](a, b ops.Operand) ops.PreallocOp[DT, T] {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return divVV[DT, T]{}
	case !aScalar && bScalar:
		return divVS[DT, T]{}
	case aScalar && !bScalar:
		return divSV[DT, T]{}
	}
}

// Pow creates an ops.Op that is correct to the shape of the given operands.
func Pow[DT any, T values.Value[DT]](a, b ops.Operand) ops.PreallocOp[DT, T] {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return powVV[DT, T]{}
	case !aScalar && bScalar:
		return powVS[DT, T]{}
	case aScalar && !bScalar:
		return powSV[DT, T]{}
	}
}

// Mod creates an ops.Op that is correct to the shape of the given operands.
func Mod[DT any, T values.Value[DT]](a, b ops.Operand) ops.PreallocOp[DT, T] {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return modVV[DT, T]{}
	case !aScalar && bScalar:
		return modVS[DT, T]{}
	case aScalar && !bScalar:
		return modSV[DT, T]{}
	}
}

// Lt creates an ops.Op that is correct to the shape of the given operands.
func Lt[DT any, T values.Value[DT], U values.V](a, b ops.Operand) ops.Desc {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	var z1 T
	var z2 U
	retSame := any(z1) == any(z2)
	if retSame {
		switch {
		default:
			fallthrough
		case !aScalar && !bScalar:
			return ltVVRS[DT, T]{}
		case !aScalar && bScalar:
			return ltVSRS[DT, T]{}
		case aScalar && !bScalar:
			return ltSVRS[DT, T]{}
		}
	}

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return ltVV[DT, T, *dense.Dense[bool]]{}
	case !aScalar && bScalar:
		return ltVS[DT, T, *dense.Dense[bool]]{}
	case aScalar && !bScalar:
		return ltSV[DT, T, *dense.Dense[bool]]{}
	}
}

// Lte creates an ops.Op that is correct to the shape of the given operands.
func Lte[DT any, T values.Value[DT], U values.V](a, b ops.Operand) ops.Desc {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	var z1 T
	var z2 U
	retSame := any(z1) == any(z2)
	if retSame {
		switch {
		default:
			fallthrough
		case !aScalar && !bScalar:
			return lteVVRS[DT, T]{}
		case !aScalar && bScalar:
			return lteVSRS[DT, T]{}
		case aScalar && !bScalar:
			return lteSVRS[DT, T]{}
		}
	}

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return lteVV[DT, T, *dense.Dense[bool]]{}
	case !aScalar && bScalar:
		return lteVS[DT, T, *dense.Dense[bool]]{}
	case aScalar && !bScalar:
		return lteSV[DT, T, *dense.Dense[bool]]{}
	}
}

// Gt creates an ops.Op that is correct to the shape of the given operands.
func Gt[DT any, T values.Value[DT], U values.V](a, b ops.Operand) ops.Desc {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	var z1 T
	var z2 U
	retSame := any(z1) == any(z2)
	if retSame {
		switch {
		default:
			fallthrough
		case !aScalar && !bScalar:
			return gtVVRS[DT, T]{}
		case !aScalar && bScalar:
			return gtVSRS[DT, T]{}
		case aScalar && !bScalar:
			return gtSVRS[DT, T]{}
		}
	}

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return gtVV[DT, T, *dense.Dense[bool]]{}
	case !aScalar && bScalar:
		return gtVS[DT, T, *dense.Dense[bool]]{}
	case aScalar && !bScalar:
		return gtSV[DT, T, *dense.Dense[bool]]{}
	}
}

// Gte creates an ops.Op that is correct to the shape of the given operands.
func Gte[DT any, T values.Value[DT], U values.V](a, b ops.Operand) ops.Desc {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	var z1 T
	var z2 U
	retSame := any(z1) == any(z2)
	if retSame {
		switch {
		default:
			fallthrough
		case !aScalar && !bScalar:
			return gteVVRS[DT, T]{}
		case !aScalar && bScalar:
			return gteVSRS[DT, T]{}
		case aScalar && !bScalar:
			return gteSVRS[DT, T]{}
		}
	}

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return gteVV[DT, T, *dense.Dense[bool]]{}
	case !aScalar && bScalar:
		return gteVS[DT, T, *dense.Dense[bool]]{}
	case aScalar && !bScalar:
		return gteSV[DT, T, *dense.Dense[bool]]{}
	}
}

// ElEq creates an ops.Op that is correct to the shape of the given operands.
func ElEq[DT any, T values.Value[DT], U values.V](a, b ops.Operand) ops.Desc {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	var z1 T
	var z2 U
	retSame := any(z1) == any(z2)
	if retSame {
		switch {
		default:
			fallthrough
		case !aScalar && !bScalar:
			return elEqVVRS[DT, T]{}
		case !aScalar && bScalar:
			return elEqVSRS[DT, T]{}
		case aScalar && !bScalar:
			return elEqSVRS[DT, T]{}
		}
	}

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return elEqVV[DT, T, *dense.Dense[bool]]{}
	case !aScalar && bScalar:
		return elEqVS[DT, T, *dense.Dense[bool]]{}
	case aScalar && !bScalar:
		return elEqSV[DT, T, *dense.Dense[bool]]{}
	}
}

// ElNe creates an ops.Op that is correct to the shape of the given operands.
func ElNe[DT any, T values.Value[DT], U values.V](a, b ops.Operand) ops.Desc {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	var z1 T
	var z2 U
	retSame := any(z1) == any(z2)
	if retSame {
		switch {
		default:
			fallthrough
		case !aScalar && !bScalar:
			return elNeVVRS[DT, T]{}
		case !aScalar && bScalar:
			return elNeVSRS[DT, T]{}
		case aScalar && !bScalar:
			return elNeSVRS[DT, T]{}
		}
	}

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return elNeVV[DT, T, *dense.Dense[bool]]{}
	case !aScalar && bScalar:
		return elNeVS[DT, T, *dense.Dense[bool]]{}
	case aScalar && !bScalar:
		return elNeSV[DT, T, *dense.Dense[bool]]{}
	}
}
