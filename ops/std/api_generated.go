package stdops

import (
	"gorgonia.org/gorgonia/ops"
	"gorgonia.org/gorgonia/values"
)

// Code generated by genops, which is a ops generation tool for Gorgonia. DO NOT EDIT.

// Add creates an ops.Op that is correct to the shape of the given operands.
func Add[DT any, T values.Value[DT]](a, b ops.Operand) ops.PreallocOp[DT, T] {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return addVV[DT, T]{}
	case !aScalar && bScalar:
		return addVS[DT, T]{}
	case aScalar && !bScalar:
		return addSV[DT, T]{}
	}
}

// Sub creates an ops.Op that is correct to the shape of the given operands.
func Sub[DT any, T values.Value[DT]](a, b ops.Operand) ops.PreallocOp[DT, T] {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return subVV[DT, T]{}
	case !aScalar && bScalar:
		return subVS[DT, T]{}
	case aScalar && !bScalar:
		return subSV[DT, T]{}
	}
}

// Mul creates an ops.Op that is correct to the shape of the given operands.
func Mul[DT any, T values.Value[DT]](a, b ops.Operand) ops.PreallocOp[DT, T] {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return mulVV[DT, T]{}
	case !aScalar && bScalar:
		return mulVS[DT, T]{}
	case aScalar && !bScalar:
		return mulSV[DT, T]{}
	}
}

// Div creates an ops.Op that is correct to the shape of the given operands.
func Div[DT any, T values.Value[DT]](a, b ops.Operand) ops.PreallocOp[DT, T] {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return divVV[DT, T]{}
	case !aScalar && bScalar:
		return divVS[DT, T]{}
	case aScalar && !bScalar:
		return divSV[DT, T]{}
	}
}

// Pow creates an ops.Op that is correct to the shape of the given operands.
func Pow[DT any, T values.Value[DT]](a, b ops.Operand) ops.PreallocOp[DT, T] {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return powVV[DT, T]{}
	case !aScalar && bScalar:
		return powVS[DT, T]{}
	case aScalar && !bScalar:
		return powSV[DT, T]{}
	}
}

// Mod creates an ops.Op that is correct to the shape of the given operands.
func Mod[DT any, T values.Value[DT]](a, b ops.Operand) ops.PreallocOp[DT, T] {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return modVV[DT, T]{}
	case !aScalar && bScalar:
		return modVS[DT, T]{}
	case aScalar && !bScalar:
		return modSV[DT, T]{}
	}
}

// Lt creates an ops.Op that is correct to the shape of the given operands.
func Lt[DT any, T values.Value[DT]](a, b ops.Operand, retSame bool) ops.PreallocOp[DT, T] {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return ltVV[DT, T]{ltOp[DT, T]{retSame: retSame}, binopVV{}}
	case !aScalar && bScalar:
		return ltVS[DT, T]{ltOp[DT, T]{retSame: retSame}, binopVS{}}
	case aScalar && !bScalar:
		return ltSV[DT, T]{ltOp[DT, T]{retSame: retSame}, binopSV{}}
	}
}

// Lte creates an ops.Op that is correct to the shape of the given operands.
func Lte[DT any, T values.Value[DT]](a, b ops.Operand, retSame bool) ops.PreallocOp[DT, T] {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return lteVV[DT, T]{lteOp[DT, T]{retSame: retSame}, binopVV{}}
	case !aScalar && bScalar:
		return lteVS[DT, T]{lteOp[DT, T]{retSame: retSame}, binopVS{}}
	case aScalar && !bScalar:
		return lteSV[DT, T]{lteOp[DT, T]{retSame: retSame}, binopSV{}}
	}
}

// Gt creates an ops.Op that is correct to the shape of the given operands.
func Gt[DT any, T values.Value[DT]](a, b ops.Operand, retSame bool) ops.PreallocOp[DT, T] {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return gtVV[DT, T]{gtOp[DT, T]{retSame: retSame}, binopVV{}}
	case !aScalar && bScalar:
		return gtVS[DT, T]{gtOp[DT, T]{retSame: retSame}, binopVS{}}
	case aScalar && !bScalar:
		return gtSV[DT, T]{gtOp[DT, T]{retSame: retSame}, binopSV{}}
	}
}

// Gte creates an ops.Op that is correct to the shape of the given operands.
func Gte[DT any, T values.Value[DT]](a, b ops.Operand, retSame bool) ops.PreallocOp[DT, T] {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return gteVV[DT, T]{gteOp[DT, T]{retSame: retSame}, binopVV{}}
	case !aScalar && bScalar:
		return gteVS[DT, T]{gteOp[DT, T]{retSame: retSame}, binopVS{}}
	case aScalar && !bScalar:
		return gteSV[DT, T]{gteOp[DT, T]{retSame: retSame}, binopSV{}}
	}
}

// ElEq creates an ops.Op that is correct to the shape of the given operands.
func ElEq[DT any, T values.Value[DT]](a, b ops.Operand, retSame bool) ops.PreallocOp[DT, T] {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return elEqVV[DT, T]{elEqOp[DT, T]{retSame: retSame}, binopVV{}}
	case !aScalar && bScalar:
		return elEqVS[DT, T]{elEqOp[DT, T]{retSame: retSame}, binopVS{}}
	case aScalar && !bScalar:
		return elEqSV[DT, T]{elEqOp[DT, T]{retSame: retSame}, binopSV{}}
	}
}

// ElNe creates an ops.Op that is correct to the shape of the given operands.
func ElNe[DT any, T values.Value[DT]](a, b ops.Operand, retSame bool) ops.PreallocOp[DT, T] {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return elNeVV[DT, T]{elNeOp[DT, T]{retSame: retSame}, binopVV{}}
	case !aScalar && bScalar:
		return elNeVS[DT, T]{elNeOp[DT, T]{retSame: retSame}, binopVS{}}
	case aScalar && !bScalar:
		return elNeSV[DT, T]{elNeOp[DT, T]{retSame: retSame}, binopSV{}}
	}
}
