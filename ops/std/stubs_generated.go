package stdops

import (
	"context"

	"gorgonia.org/gorgonia/exprgraph"
	"gorgonia.org/gorgonia/internal/datatypes"
	"gorgonia.org/gorgonia/values/dual"
)

// Code generated by genops, which is a ops generation tool for Gorgonia. DO NOT EDIT.

// DoDiff is the method that allows automatic differentiation of `sub` g.
func (op subOp[DT, T]) DoDiff(ctx context.Context, inputs []datatypes.Tensor, output datatypes.Tensor) error {
	adv := exprgraph.T2B[DT](inputs[0]).(*dual.Dual[DT, T])
	bdv := exprgraph.T2B[DT](inputs[1]).(*dual.Dual[DT, T])
	cdv := exprgraph.T2B[DT](output).(*dual.Dual[DT, T])

	advd := adv.Deriv()
	bdvd := bdv.Deriv()

	_, _, _ = cdv, advd, bdvd
	panic("Not implemented")
}

// DoDiff is the method that allows automatic differentiation of `mul` g.
func (op mulOp[DT, T]) DoDiff(ctx context.Context, inputs []datatypes.Tensor, output datatypes.Tensor) error {
	adv := exprgraph.T2B[DT](inputs[0]).(*dual.Dual[DT, T])
	bdv := exprgraph.T2B[DT](inputs[1]).(*dual.Dual[DT, T])
	cdv := exprgraph.T2B[DT](output).(*dual.Dual[DT, T])

	advd := adv.Deriv()
	bdvd := bdv.Deriv()

	_, _, _ = cdv, advd, bdvd
	panic("Not implemented")
}

// DoDiff is the method that allows automatic differentiation of `div` g.
func (op divOp[DT, T]) DoDiff(ctx context.Context, inputs []datatypes.Tensor, output datatypes.Tensor) error {
	adv := exprgraph.T2B[DT](inputs[0]).(*dual.Dual[DT, T])
	bdv := exprgraph.T2B[DT](inputs[1]).(*dual.Dual[DT, T])
	cdv := exprgraph.T2B[DT](output).(*dual.Dual[DT, T])

	advd := adv.Deriv()
	bdvd := bdv.Deriv()

	_, _, _ = cdv, advd, bdvd
	panic("Not implemented")
}

// SymDiff performs the symbolic differentiation of pow.
func (op powOp[DT, T]) SymDiff(g *exprgraph.Graph, inputs []*exprgraph.Node, output *exprgraph.Node, grad *exprgraph.Node) (retVal []*exprgraph.Node, err error) {
	panic("not implemented")
}

// DoDiff is the method that allows automatic differentiation of `pow` g.
func (op powOp[DT, T]) DoDiff(ctx context.Context, inputs []datatypes.Tensor, output datatypes.Tensor) error {
	adv := exprgraph.T2B[DT](inputs[0]).(*dual.Dual[DT, T])
	bdv := exprgraph.T2B[DT](inputs[1]).(*dual.Dual[DT, T])
	cdv := exprgraph.T2B[DT](output).(*dual.Dual[DT, T])

	advd := adv.Deriv()
	bdvd := bdv.Deriv()

	_, _, _ = cdv, advd, bdvd
	panic("Not implemented")
}

// SymDiff performs the symbolic differentiation of sin.
func (op sinOp[DT, T]) SymDiff(g *exprgraph.Graph, inputs []*exprgraph.Node, output *exprgraph.Node, grad *exprgraph.Node) (retVal []*exprgraph.Node, err error) {
	panic("not implemented")
}

// DoDiff is the method that allows automatic differentiation of `sin` g.
func (op sinOp[DT, T]) DoDiff(ctx context.Context, inputs []datatypes.Tensor, output datatypes.Tensor) error {
	adv := exprgraph.T2B[DT](inputs[0]).(*dual.Dual[DT, T])
	bdv := exprgraph.T2B[DT](inputs[1]).(*dual.Dual[DT, T])
	cdv := exprgraph.T2B[DT](output).(*dual.Dual[DT, T])

	advd := adv.Deriv()
	bdvd := bdv.Deriv()

	_, _, _ = cdv, advd, bdvd
	panic("Not implemented")
}

// SymDiff performs the symbolic differentiation of cos.
func (op cosOp[DT, T]) SymDiff(g *exprgraph.Graph, inputs []*exprgraph.Node, output *exprgraph.Node, grad *exprgraph.Node) (retVal []*exprgraph.Node, err error) {
	panic("not implemented")
}

// DoDiff is the method that allows automatic differentiation of `cos` g.
func (op cosOp[DT, T]) DoDiff(ctx context.Context, inputs []datatypes.Tensor, output datatypes.Tensor) error {
	adv := exprgraph.T2B[DT](inputs[0]).(*dual.Dual[DT, T])
	bdv := exprgraph.T2B[DT](inputs[1]).(*dual.Dual[DT, T])
	cdv := exprgraph.T2B[DT](output).(*dual.Dual[DT, T])

	advd := adv.Deriv()
	bdvd := bdv.Deriv()

	_, _, _ = cdv, advd, bdvd
	panic("Not implemented")
}

// SymDiff performs the symbolic differentiation of exp.
func (op expOp[DT, T]) SymDiff(g *exprgraph.Graph, inputs []*exprgraph.Node, output *exprgraph.Node, grad *exprgraph.Node) (retVal []*exprgraph.Node, err error) {
	panic("not implemented")
}

// DoDiff is the method that allows automatic differentiation of `exp` g.
func (op expOp[DT, T]) DoDiff(ctx context.Context, inputs []datatypes.Tensor, output datatypes.Tensor) error {
	adv := exprgraph.T2B[DT](inputs[0]).(*dual.Dual[DT, T])
	bdv := exprgraph.T2B[DT](inputs[1]).(*dual.Dual[DT, T])
	cdv := exprgraph.T2B[DT](output).(*dual.Dual[DT, T])

	advd := adv.Deriv()
	bdvd := bdv.Deriv()

	_, _, _ = cdv, advd, bdvd
	panic("Not implemented")
}

// SymDiff performs the symbolic differentiation of ln.
func (op lnOp[DT, T]) SymDiff(g *exprgraph.Graph, inputs []*exprgraph.Node, output *exprgraph.Node, grad *exprgraph.Node) (retVal []*exprgraph.Node, err error) {
	panic("not implemented")
}

// DoDiff is the method that allows automatic differentiation of `ln` g.
func (op lnOp[DT, T]) DoDiff(ctx context.Context, inputs []datatypes.Tensor, output datatypes.Tensor) error {
	adv := exprgraph.T2B[DT](inputs[0]).(*dual.Dual[DT, T])
	bdv := exprgraph.T2B[DT](inputs[1]).(*dual.Dual[DT, T])
	cdv := exprgraph.T2B[DT](output).(*dual.Dual[DT, T])

	advd := adv.Deriv()
	bdvd := bdv.Deriv()

	_, _, _ = cdv, advd, bdvd
	panic("Not implemented")
}

// SymDiff performs the symbolic differentiation of log2.
func (op log2Op[DT, T]) SymDiff(g *exprgraph.Graph, inputs []*exprgraph.Node, output *exprgraph.Node, grad *exprgraph.Node) (retVal []*exprgraph.Node, err error) {
	panic("not implemented")
}

// DoDiff is the method that allows automatic differentiation of `log2` g.
func (op log2Op[DT, T]) DoDiff(ctx context.Context, inputs []datatypes.Tensor, output datatypes.Tensor) error {
	adv := exprgraph.T2B[DT](inputs[0]).(*dual.Dual[DT, T])
	bdv := exprgraph.T2B[DT](inputs[1]).(*dual.Dual[DT, T])
	cdv := exprgraph.T2B[DT](output).(*dual.Dual[DT, T])

	advd := adv.Deriv()
	bdvd := bdv.Deriv()

	_, _, _ = cdv, advd, bdvd
	panic("Not implemented")
}

// SymDiff performs the symbolic differentiation of neg.
func (op negOp[DT, T]) SymDiff(g *exprgraph.Graph, inputs []*exprgraph.Node, output *exprgraph.Node, grad *exprgraph.Node) (retVal []*exprgraph.Node, err error) {
	panic("not implemented")
}

// DoDiff is the method that allows automatic differentiation of `neg` g.
func (op negOp[DT, T]) DoDiff(ctx context.Context, inputs []datatypes.Tensor, output datatypes.Tensor) error {
	adv := exprgraph.T2B[DT](inputs[0]).(*dual.Dual[DT, T])
	bdv := exprgraph.T2B[DT](inputs[1]).(*dual.Dual[DT, T])
	cdv := exprgraph.T2B[DT](output).(*dual.Dual[DT, T])

	advd := adv.Deriv()
	bdvd := bdv.Deriv()

	_, _, _ = cdv, advd, bdvd
	panic("Not implemented")
}

// SymDiff performs the symbolic differentiation of square.
func (op squareOp[DT, T]) SymDiff(g *exprgraph.Graph, inputs []*exprgraph.Node, output *exprgraph.Node, grad *exprgraph.Node) (retVal []*exprgraph.Node, err error) {
	panic("not implemented")
}

// DoDiff is the method that allows automatic differentiation of `square` g.
func (op squareOp[DT, T]) DoDiff(ctx context.Context, inputs []datatypes.Tensor, output datatypes.Tensor) error {
	adv := exprgraph.T2B[DT](inputs[0]).(*dual.Dual[DT, T])
	bdv := exprgraph.T2B[DT](inputs[1]).(*dual.Dual[DT, T])
	cdv := exprgraph.T2B[DT](output).(*dual.Dual[DT, T])

	advd := adv.Deriv()
	bdvd := bdv.Deriv()

	_, _, _ = cdv, advd, bdvd
	panic("Not implemented")
}

// SymDiff performs the symbolic differentiation of sqrt.
func (op sqrtOp[DT, T]) SymDiff(g *exprgraph.Graph, inputs []*exprgraph.Node, output *exprgraph.Node, grad *exprgraph.Node) (retVal []*exprgraph.Node, err error) {
	panic("not implemented")
}

// DoDiff is the method that allows automatic differentiation of `sqrt` g.
func (op sqrtOp[DT, T]) DoDiff(ctx context.Context, inputs []datatypes.Tensor, output datatypes.Tensor) error {
	adv := exprgraph.T2B[DT](inputs[0]).(*dual.Dual[DT, T])
	bdv := exprgraph.T2B[DT](inputs[1]).(*dual.Dual[DT, T])
	cdv := exprgraph.T2B[DT](output).(*dual.Dual[DT, T])

	advd := adv.Deriv()
	bdvd := bdv.Deriv()

	_, _, _ = cdv, advd, bdvd
	panic("Not implemented")
}

// SymDiff performs the symbolic differentiation of inv.
func (op invOp[DT, T]) SymDiff(g *exprgraph.Graph, inputs []*exprgraph.Node, output *exprgraph.Node, grad *exprgraph.Node) (retVal []*exprgraph.Node, err error) {
	panic("not implemented")
}

// DoDiff is the method that allows automatic differentiation of `inv` g.
func (op invOp[DT, T]) DoDiff(ctx context.Context, inputs []datatypes.Tensor, output datatypes.Tensor) error {
	adv := exprgraph.T2B[DT](inputs[0]).(*dual.Dual[DT, T])
	bdv := exprgraph.T2B[DT](inputs[1]).(*dual.Dual[DT, T])
	cdv := exprgraph.T2B[DT](output).(*dual.Dual[DT, T])

	advd := adv.Deriv()
	bdvd := bdv.Deriv()

	_, _, _ = cdv, advd, bdvd
	panic("Not implemented")
}

// SymDiff performs the symbolic differentiation of invSqrt.
func (op invSqrtOp[DT, T]) SymDiff(g *exprgraph.Graph, inputs []*exprgraph.Node, output *exprgraph.Node, grad *exprgraph.Node) (retVal []*exprgraph.Node, err error) {
	panic("not implemented")
}

// DoDiff is the method that allows automatic differentiation of `invSqrt` g.
func (op invSqrtOp[DT, T]) DoDiff(ctx context.Context, inputs []datatypes.Tensor, output datatypes.Tensor) error {
	adv := exprgraph.T2B[DT](inputs[0]).(*dual.Dual[DT, T])
	bdv := exprgraph.T2B[DT](inputs[1]).(*dual.Dual[DT, T])
	cdv := exprgraph.T2B[DT](output).(*dual.Dual[DT, T])

	advd := adv.Deriv()
	bdvd := bdv.Deriv()

	_, _, _ = cdv, advd, bdvd
	panic("Not implemented")
}

// SymDiff performs the symbolic differentiation of log1p.
func (op log1pOp[DT, T]) SymDiff(g *exprgraph.Graph, inputs []*exprgraph.Node, output *exprgraph.Node, grad *exprgraph.Node) (retVal []*exprgraph.Node, err error) {
	panic("not implemented")
}

// DoDiff is the method that allows automatic differentiation of `log1p` g.
func (op log1pOp[DT, T]) DoDiff(ctx context.Context, inputs []datatypes.Tensor, output datatypes.Tensor) error {
	adv := exprgraph.T2B[DT](inputs[0]).(*dual.Dual[DT, T])
	bdv := exprgraph.T2B[DT](inputs[1]).(*dual.Dual[DT, T])
	cdv := exprgraph.T2B[DT](output).(*dual.Dual[DT, T])

	advd := adv.Deriv()
	bdvd := bdv.Deriv()

	_, _, _ = cdv, advd, bdvd
	panic("Not implemented")
}

// SymDiff performs the symbolic differentiation of expm1.
func (op expm1Op[DT, T]) SymDiff(g *exprgraph.Graph, inputs []*exprgraph.Node, output *exprgraph.Node, grad *exprgraph.Node) (retVal []*exprgraph.Node, err error) {
	panic("not implemented")
}

// DoDiff is the method that allows automatic differentiation of `expm1` g.
func (op expm1Op[DT, T]) DoDiff(ctx context.Context, inputs []datatypes.Tensor, output datatypes.Tensor) error {
	adv := exprgraph.T2B[DT](inputs[0]).(*dual.Dual[DT, T])
	bdv := exprgraph.T2B[DT](inputs[1]).(*dual.Dual[DT, T])
	cdv := exprgraph.T2B[DT](output).(*dual.Dual[DT, T])

	advd := adv.Deriv()
	bdvd := bdv.Deriv()

	_, _, _ = cdv, advd, bdvd
	panic("Not implemented")
}

// SymDiff performs the symbolic differentiation of cube.
func (op cubeOp[DT, T]) SymDiff(g *exprgraph.Graph, inputs []*exprgraph.Node, output *exprgraph.Node, grad *exprgraph.Node) (retVal []*exprgraph.Node, err error) {
	panic("not implemented")
}

// DoDiff is the method that allows automatic differentiation of `cube` g.
func (op cubeOp[DT, T]) DoDiff(ctx context.Context, inputs []datatypes.Tensor, output datatypes.Tensor) error {
	adv := exprgraph.T2B[DT](inputs[0]).(*dual.Dual[DT, T])
	bdv := exprgraph.T2B[DT](inputs[1]).(*dual.Dual[DT, T])
	cdv := exprgraph.T2B[DT](output).(*dual.Dual[DT, T])

	advd := adv.Deriv()
	bdvd := bdv.Deriv()

	_, _, _ = cdv, advd, bdvd
	panic("Not implemented")
}

// SymDiff performs the symbolic differentiation of tanh.
func (op tanhOp[DT, T]) SymDiff(g *exprgraph.Graph, inputs []*exprgraph.Node, output *exprgraph.Node, grad *exprgraph.Node) (retVal []*exprgraph.Node, err error) {
	panic("not implemented")
}

// DoDiff is the method that allows automatic differentiation of `tanh` g.
func (op tanhOp[DT, T]) DoDiff(ctx context.Context, inputs []datatypes.Tensor, output datatypes.Tensor) error {
	adv := exprgraph.T2B[DT](inputs[0]).(*dual.Dual[DT, T])
	bdv := exprgraph.T2B[DT](inputs[1]).(*dual.Dual[DT, T])
	cdv := exprgraph.T2B[DT](output).(*dual.Dual[DT, T])

	advd := adv.Deriv()
	bdvd := bdv.Deriv()

	_, _, _ = cdv, advd, bdvd
	panic("Not implemented")
}
